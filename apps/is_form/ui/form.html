<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fujifilm Printer Settings</title>
    <style>
      :root {
        --color-bg: #ffffff;
        --color-text: #13202e;
        --color-border: #e6ebf2;
        --color-primary: #0f5a9c;
        --color-primary-strong: #0a4a81;
        --color-focus: rgba(15, 90, 156, 0.15);
        --color-error: #b42318;
        --color-error-bg: #fef3f2;
        --color-muted: #5f6b78;
        --header-height: 76px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
        color: var(--color-text);
        background: var(--color-bg);
        padding-top: calc(var(--header-height) + 1px);
        padding-bottom: 92px;
      }

      button,
      input,
      select,
      textarea {
        font: inherit;
      }

      :focus-visible {
        outline: 3px solid var(--color-focus);
        outline-offset: 1px;
      }

      .app-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 40;
        background: #fff;
        border-bottom: 1px solid var(--color-border);
      }

      .app-header-inner {
        max-width: 1200px;
        margin: 0 auto;
        min-height: var(--header-height);
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .app-header img {
        height: 32px;
        width: auto;
        display: block;
      }

      .app-header-title {
        font-size: 0.92rem;
        color: var(--color-muted);
        text-align: right;
      }

      .header-accent {
        height: 2px;
        background: var(--color-primary);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 1.1rem 1rem 0;
      }

      .card {
        border: 1px solid var(--color-border);
        border-radius: 12px;
        background: #fff;
        padding: 1rem;
      }

      .profile-card {
        margin-bottom: 1rem;
      }

      .profile-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(220px, 1fr));
        gap: 0.85rem;
      }

      .field-wrap {
        display: flex;
        flex-direction: column;
        gap: 0.36rem;
      }

      .field-wrap label {
        font-size: 0.86rem;
        font-weight: 700;
      }

      .required-mark {
        color: var(--color-error);
      }

      input[type="text"],
      select,
      textarea {
        border: 1px solid #b8c3d1;
        border-radius: 8px;
        padding: 0.54rem 0.62rem;
        color: var(--color-text);
        width: 100%;
        background: #fff;
      }

      textarea {
        min-height: 88px;
        resize: vertical;
      }

      .field-wrap.has-error input,
      .field-wrap.has-error select,
      .field-wrap.has-error textarea {
        border-color: var(--color-error);
        background: var(--color-error-bg);
      }

      .field-error {
        min-height: 1rem;
        font-size: 0.8rem;
        color: var(--color-error);
      }

      .profile-actions {
        margin-top: 0.95rem;
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }

      button {
        border: 1px solid #c1cbda;
        background: #f5f8fc;
        color: var(--color-text);
        border-radius: 8px;
        padding: 0.48rem 0.88rem;
        font-weight: 700;
        cursor: pointer;
      }

      button:hover {
        background: #ecf2f8;
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .btn-primary {
        background: var(--color-primary);
        border-color: var(--color-primary);
        color: #fff;
      }

      .btn-primary:hover {
        background: var(--color-primary-strong);
      }

      .status {
        margin-top: 0.9rem;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        background: #f5f8fc;
        padding: 0.65rem 0.75rem;
        font-size: 0.9rem;
      }

      .status.error {
        border-color: #f4c7c3;
        background: var(--color-error-bg);
        color: var(--color-error);
      }

      .status.success {
        border-color: #c7e3c7;
        background: #eff9ef;
      }

      .section-stack {
        display: grid;
        gap: 0.9rem;
      }

      .section-card {
        border: 1px solid var(--color-border);
        border-radius: 12px;
        background: #fff;
        padding: 0.95rem;
      }

      .section-title {
        margin: 0;
        font-size: 1.08rem;
        font-weight: 700;
      }

      .section-divider {
        height: 1px;
        background: var(--color-border);
        margin: 0.75rem 0;
      }

      .group-card {
        border: 1px solid var(--color-border);
        border-radius: 10px;
        margin-left: 0.7rem;
        padding: 0.8rem;
        background: #fff;
      }

      .group-title {
        margin: 0 0 0.75rem;
        font-size: 0.98rem;
        font-weight: 700;
      }

      .subgroup-card {
        border: 1px solid var(--color-border);
        border-radius: 10px;
        margin: 0 0 0.7rem;
        background: #fff;
        overflow: hidden;
      }

      .subgroup-header {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.8rem;
        border: 0;
        border-bottom: 1px solid var(--color-border);
        border-radius: 0;
        padding: 0.68rem 0.75rem;
        background: #f8fbff;
        text-align: left;
      }
      .subgroup-title-wrap {
        display: inline-flex;
        align-items: center;
        gap: 0.52rem;
      }

      .chevron {
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 7px solid var(--color-muted);
        transition: transform 0.18s ease;
      }

      .subgroup-header[aria-expanded="false"] .chevron {
        transform: rotate(-90deg);
      }

      .subgroup-summary {
        color: var(--color-muted);
        font-size: 0.82rem;
      }

      .subgroup-body {
        padding: 0.82rem;
      }

      .subgroup-body[hidden] {
        display: none;
      }

      .field-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(220px, 1fr));
        gap: 0.8rem;
      }

      .checkbox-inline {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        min-height: 40px;
      }

      .checkbox-inline input {
        margin: 0;
      }

      .empty-note {
        color: var(--color-muted);
        font-size: 0.9rem;
      }

      .sticky-save {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 45;
        background: #fff;
        border-top: 1px solid var(--color-border);
        padding: 0.72rem 1rem;
        display: none;
      }

      .sticky-save.show {
        display: block;
      }

      .sticky-save-inner {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.8rem;
      }

      .sticky-text {
        font-weight: 700;
        color: var(--color-text);
      }

      .sticky-actions {
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }

      @media (max-width: 980px) {
        .profile-grid {
          grid-template-columns: 1fr 1fr;
        }
      }

      @media (max-width: 760px) {
        .app-header-inner {
          align-items: flex-start;
          flex-direction: column;
        }

        .app-header-title {
          text-align: left;
        }

        .profile-grid,
        .field-grid {
          grid-template-columns: 1fr;
        }

        .group-card {
          margin-left: 0;
        }

        .sticky-save-inner {
          align-items: flex-start;
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="app-header-inner">
        <img src="/assets/logo.svg" alt="Fujifilm logo" />
        <div class="app-header-title">
          FUJIFILM Business Innovation | Australia
        </div>
      </div>
      <div class="header-accent" aria-hidden="true"></div>
    </header>

    <main>
      <section class="card profile-card">
        <div class="profile-grid">
          <div class="field-wrap" data-meta-field="accountNumber">
            <label for="accountNumber"
              >Account <span class="required-mark">*</span></label
            >
            <input id="accountNumber" type="text" autocomplete="off" />
            <div id="error-accountNumber" class="field-error"></div>
          </div>

          <div class="field-wrap" data-meta-field="variation">
            <label for="variation"
              >Variation <span class="required-mark">*</span></label
            >
            <input id="variation" type="text" autocomplete="off" />
            <div id="error-variation" class="field-error"></div>
          </div>

          <div class="field-wrap" data-meta-field="displayName">
            <label for="displayName">Profile Name</label>
            <input id="displayName" type="text" autocomplete="off" />
            <div id="error-displayName" class="field-error"></div>
          </div>
        </div>

        <div class="profile-actions">
          <button id="loadBtn" type="button">Load</button>
          <button id="clearBtn" type="button">New/Clear</button>
          <button id="saveBtn" type="button" class="btn-primary" disabled>
            Save
          </button>
        </div>

        <div id="status" class="status" aria-live="polite">
          Loading schema...
        </div>
      </section>

      <section
        id="sectionsContainer"
        class="section-stack"
        aria-live="polite"
      ></section>
    </main>

    <div id="stickySave" class="sticky-save" aria-live="polite">
      <div class="sticky-save-inner">
        <div class="sticky-text">Unsaved changes</div>
        <div class="sticky-actions">
          <button id="stickyDiscardBtn" type="button">Discard</button>
          <button id="stickySaveBtn" type="button" class="btn-primary">
            Save changes
          </button>
        </div>
      </div>
    </div>

    <script>
      const SESSION_COLLAPSE_KEY = "is_form_subgroup_collapsed";

      const elements = {
        account: document.getElementById("accountNumber"),
        variation: document.getElementById("variation"),
        displayName: document.getElementById("displayName"),
        loadBtn: document.getElementById("loadBtn"),
        clearBtn: document.getElementById("clearBtn"),
        saveBtn: document.getElementById("saveBtn"),
        status: document.getElementById("status"),
        sectionsContainer: document.getElementById("sectionsContainer"),
        stickySave: document.getElementById("stickySave"),
        stickyDiscardBtn: document.getElementById("stickyDiscardBtn"),
        stickySaveBtn: document.getElementById("stickySaveBtn"),
      };

      let schema = null;
      let formState = {};
      let validationErrors = {};
      let dirty = false;
      let snapshot = null;

      const fieldIndex = new Map();
      const fieldOrder = [];
      const dependencyIndex = new Map();
      const subgroupCollapsed = new Map();

      function setStatus(message, type = "info") {
        elements.status.textContent = message;
        elements.status.classList.remove("error", "success");
        if (type === "error") elements.status.classList.add("error");
        if (type === "success") elements.status.classList.add("success");
      }

      function loadCollapseStateFromSession() {
        subgroupCollapsed.clear();
        try {
          const raw = sessionStorage.getItem(SESSION_COLLAPSE_KEY);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") return;
          Object.entries(parsed).forEach(([key, value]) => {
            subgroupCollapsed.set(key, Boolean(value));
          });
        } catch {
          // ignore invalid cache
        }
      }

      function persistCollapseStateToSession() {
        const obj = {};
        subgroupCollapsed.forEach((value, key) => {
          obj[key] = Boolean(value);
        });
        sessionStorage.setItem(SESSION_COLLAPSE_KEY, JSON.stringify(obj));
      }

      function getAllSubgroups() {
        const sections = Array.isArray(schema?.sections) ? schema.sections : [];
        const all = [];
        sections.forEach((section) => {
          const groups = Array.isArray(section.groups) ? section.groups : [];
          groups.forEach((group) => {
            const subgroups = Array.isArray(group.subgroups)
              ? group.subgroups
              : [];
            subgroups.forEach((subgroup) => {
              all.push({ section, group, subgroup });
            });
          });
        });
        return all;
      }
      function getDefaultForField(field) {
        if (Object.prototype.hasOwnProperty.call(field, "default")) {
          return field.default;
        }
        if (field.control === "checkbox") return false;
        return "";
      }

      function normalizeValueForField(field, value) {
        if (field.control === "checkbox") {
          return value === true;
        }
        return String(value ?? "");
      }

      function buildIndexes() {
        fieldIndex.clear();
        fieldOrder.length = 0;
        dependencyIndex.clear();

        getAllSubgroups().forEach(({ section, group, subgroup }) => {
          const fields = Array.isArray(subgroup.fields) ? subgroup.fields : [];
          if (!subgroupCollapsed.has(subgroup.id)) {
            subgroupCollapsed.set(
              subgroup.id,
              subgroup.defaultCollapsed === true,
            );
          }

          fields.forEach((field) => {
            fieldOrder.push(field.id);
            fieldIndex.set(field.id, {
              sectionId: section.id,
              groupId: group.id,
              subgroupId: subgroup.id,
              field,
            });

            if (field.visibleIf?.fieldId) {
              const depId = field.visibleIf.fieldId;
              if (!dependencyIndex.has(depId)) dependencyIndex.set(depId, []);
              dependencyIndex.get(depId).push(field.id);
            }
          });
        });
      }

      function initializeStateFromSchema() {
        const next = {};
        fieldOrder.forEach((fieldId) => {
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          next[fieldId] = getDefaultForField(meta.field);
        });
        formState = next;
      }

      function isFieldConditionVisible(field) {
        if (!field.visibleIf) return true;
        return formState[field.visibleIf.fieldId] === field.visibleIf.equals;
      }

      function isFieldActive(fieldId) {
        const meta = fieldIndex.get(fieldId);
        if (!meta) return false;
        const isCollapsed = subgroupCollapsed.get(meta.subgroupId) === true;
        if (isCollapsed) return false;
        return isFieldConditionVisible(meta.field);
      }

      function clearMetaErrors() {
        ["accountNumber", "variation", "displayName"].forEach((id) => {
          const wrap = document.querySelector(
            `.field-wrap[data-meta-field="${id}"]`,
          );
          const error = document.getElementById(`error-${id}`);
          if (wrap) wrap.classList.remove("has-error");
          if (error) error.textContent = "";
        });
      }

      function renderInlineErrors() {
        clearMetaErrors();
        document.querySelectorAll("[id^='error-field-']").forEach((node) => {
          node.textContent = "";
        });
        document.querySelectorAll(".field-wrap").forEach((node) => {
          if (node.dataset.fieldId) node.classList.remove("has-error");
        });

        Object.entries(validationErrors).forEach(([key, message]) => {
          if (
            key === "accountNumber" ||
            key === "variation" ||
            key === "displayName"
          ) {
            const wrap = document.querySelector(
              `.field-wrap[data-meta-field="${key}"]`,
            );
            const error = document.getElementById(`error-${key}`);
            if (wrap) wrap.classList.add("has-error");
            if (error) error.textContent = message;
            return;
          }

          const wrap = document.querySelector(
            `.field-wrap[data-field-id="${CSS.escape(key)}"]`,
          );
          const error = document.getElementById(`error-field-${key}`);
          if (wrap) wrap.classList.add("has-error");
          if (error) error.textContent = message;
        });
      }

      function readSnapshot() {
        const values = {};
        fieldOrder.forEach((fieldId) => {
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          values[fieldId] = normalizeValueForField(
            meta.field,
            formState[fieldId],
          );
        });
        return {
          accountNumber: elements.account.value.trim(),
          variation: elements.variation.value.trim(),
          displayName: elements.displayName.value.trim(),
          values,
        };
      }

      function snapshotsEqual(a, b) {
        if (!a || !b) return false;
        if (a.accountNumber !== b.accountNumber) return false;
        if (a.variation !== b.variation) return false;
        if (a.displayName !== b.displayName) return false;

        for (const fieldId of fieldOrder) {
          if (a.values[fieldId] !== b.values[fieldId]) return false;
        }
        return true;
      }

      function updateDirtyState() {
        dirty = !snapshotsEqual(readSnapshot(), snapshot);
        elements.saveBtn.disabled = !dirty;
        handleStickyBar();
      }

      function setFieldValue(fieldId, nextValue, rerenderForVisibility = true) {
        formState[fieldId] = nextValue;
        if (validationErrors[fieldId]) {
          delete validationErrors[fieldId];
        }
        if (rerenderForVisibility && dependencyIndex.has(fieldId)) {
          renderSections();
        } else {
          renderInlineErrors();
        }
        updateDirtyState();
      }

      function renderField(field) {
        if (!isFieldConditionVisible(field)) return null;

        const wrapper = document.createElement("div");
        wrapper.className = "field-wrap";
        wrapper.dataset.fieldId = field.id;

        if (field.control === "checkbox") {
          const inputId = `input-${field.id}`;
          const row = document.createElement("div");
          row.className = "checkbox-inline";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.id = inputId;
          input.checked = Boolean(formState[field.id]);
          input.addEventListener("change", () => {
            setFieldValue(field.id, input.checked, true);
          });

          const label = document.createElement("label");
          label.htmlFor = inputId;
          label.textContent = field.label;

          row.appendChild(input);
          row.appendChild(label);

          if (field.required) {
            const mark = document.createElement("span");
            mark.className = "required-mark";
            mark.textContent = "*";
            row.appendChild(mark);
          }

          wrapper.appendChild(row);
        } else {
          const label = document.createElement("label");
          label.htmlFor = `input-${field.id}`;
          label.innerHTML = field.required
            ? `${escapeHtml(field.label)} <span class="required-mark">*</span>`
            : escapeHtml(field.label);
          wrapper.appendChild(label);

          if (field.control === "textarea") {
            const textarea = document.createElement("textarea");
            textarea.id = `input-${field.id}`;
            textarea.value = String(formState[field.id] ?? "");
            textarea.addEventListener("input", () => {
              setFieldValue(field.id, textarea.value, false);
            });
            wrapper.appendChild(textarea);
          } else if (field.control === "select") {
            const select = document.createElement("select");
            select.id = `input-${field.id}`;

            const emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "-- Select --";
            select.appendChild(emptyOption);

            const options = Array.isArray(field.options) ? field.options : [];
            options.forEach((optionValue) => {
              const option = document.createElement("option");
              option.value = String(optionValue);
              option.textContent = String(optionValue);
              select.appendChild(option);
            });

            select.value = String(formState[field.id] ?? "");
            select.addEventListener("change", () => {
              setFieldValue(field.id, select.value, true);
            });
            wrapper.appendChild(select);
          } else {
            const input = document.createElement("input");
            input.type = "text";
            input.id = `input-${field.id}`;
            input.value = String(formState[field.id] ?? "");
            input.addEventListener("input", () => {
              setFieldValue(field.id, input.value, false);
            });
            wrapper.appendChild(input);
          }
        }

        const error = document.createElement("div");
        error.className = "field-error";
        error.id = `error-field-${field.id}`;
        wrapper.appendChild(error);

        if (validationErrors[field.id]) {
          wrapper.classList.add("has-error");
          error.textContent = validationErrors[field.id];
        }

        return wrapper;
      }
      function renderSubgroups(group, parent) {
        const subgroups = Array.isArray(group.subgroups) ? group.subgroups : [];

        subgroups.forEach((subgroup) => {
          const card = document.createElement("div");
          card.className = "subgroup-card";

          const header = document.createElement("button");
          header.type = "button";
          header.className = "subgroup-header";

          const isCollapsed = subgroupCollapsed.get(subgroup.id) === true;
          const bodyId = `subgroup-body-${subgroup.id}`;

          header.setAttribute("aria-expanded", String(!isCollapsed));
          header.setAttribute("aria-controls", bodyId);

          const titleWrap = document.createElement("span");
          titleWrap.className = "subgroup-title-wrap";

          const chevron = document.createElement("span");
          chevron.className = "chevron";
          chevron.setAttribute("aria-hidden", "true");

          const title = document.createElement("span");
          title.textContent = subgroup.title || subgroup.id;

          titleWrap.appendChild(chevron);
          titleWrap.appendChild(title);

          const fields = Array.isArray(subgroup.fields) ? subgroup.fields : [];
          const summary = document.createElement("span");
          summary.className = "subgroup-summary";
          summary.textContent = `${fields.length} setting${fields.length === 1 ? "" : "s"}`;

          header.appendChild(titleWrap);
          header.appendChild(summary);

          const body = document.createElement("div");
          body.className = "subgroup-body";
          body.id = bodyId;
          body.hidden = isCollapsed;

          header.addEventListener("click", () => {
            const nextCollapsed = !(
              subgroupCollapsed.get(subgroup.id) === true
            );
            subgroupCollapsed.set(subgroup.id, nextCollapsed);
            persistCollapseStateToSession();
            renderSections();
            updateDirtyState();
          });

          card.appendChild(header);
          card.appendChild(body);

          if (!isCollapsed) {
            const grid = document.createElement("div");
            grid.className = "field-grid";

            fields.forEach((field) => {
              const fieldEl = renderField(field);
              if (fieldEl) {
                grid.appendChild(fieldEl);
              }
            });

            if (!grid.childElementCount) {
              const empty = document.createElement("p");
              empty.className = "empty-note";
              empty.textContent = "No visible settings in this subgroup.";
              body.appendChild(empty);
            } else {
              body.appendChild(grid);
            }
          }

          parent.appendChild(card);
        });
      }

      function renderGroups(section, parent) {
        const groups = Array.isArray(section.groups) ? section.groups : [];

        groups.forEach((group) => {
          const card = document.createElement("div");
          card.className = "group-card";

          const title = document.createElement("h3");
          title.className = "group-title";
          title.textContent = group.title || group.id;
          card.appendChild(title);

          renderSubgroups(group, card);
          parent.appendChild(card);
        });
      }

      function renderSections() {
        elements.sectionsContainer.innerHTML = "";

        const sections = Array.isArray(schema?.sections) ? schema.sections : [];
        if (!sections.length) {
          const empty = document.createElement("div");
          empty.className = "card empty-note";
          empty.textContent = "Schema contains no sections.";
          elements.sectionsContainer.appendChild(empty);
          return;
        }

        sections.forEach((section) => {
          const sectionCard = document.createElement("section");
          sectionCard.className = "section-card";

          const title = document.createElement("h2");
          title.className = "section-title";
          title.textContent = section.title || section.id;
          sectionCard.appendChild(title);

          const divider = document.createElement("div");
          divider.className = "section-divider";
          divider.setAttribute("aria-hidden", "true");
          sectionCard.appendChild(divider);

          renderGroups(section, sectionCard);
          elements.sectionsContainer.appendChild(sectionCard);
        });

        renderInlineErrors();
      }

      function validateForm() {
        const nextErrors = {};

        if (!elements.account.value.trim()) {
          nextErrors.accountNumber = "Account is required.";
        }
        if (!elements.variation.value.trim()) {
          nextErrors.variation = "Variation is required.";
        }

        fieldOrder.forEach((fieldId) => {
          if (!isFieldActive(fieldId)) return;

          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          const field = meta.field;
          const value = formState[fieldId];

          if (field.required) {
            if (field.control === "checkbox") {
              if (value !== true) {
                nextErrors[fieldId] = `${field.label} must be checked.`;
              }
            } else if (String(value ?? "").trim() === "") {
              nextErrors[fieldId] = `${field.label} is required.`;
            }
          }

          if (field.control === "select") {
            const normalized = String(value ?? "");
            const options = Array.isArray(field.options)
              ? field.options.map(String)
              : [];
            if (normalized && !options.includes(normalized)) {
              nextErrors[fieldId] = `${field.label} has an invalid option.`;
            }
          }
        });

        validationErrors = nextErrors;
        renderInlineErrors();
        handleStickyBar();

        return Object.keys(nextErrors).length === 0;
      }

      function buildSaveValues() {
        const values = [];
        fieldOrder.forEach((fieldId) => {
          if (!isFieldActive(fieldId)) return;
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          const field = meta.field;
          const rawValue = formState[fieldId];
          values.push({
            settingId: field.id,
            value:
              field.control === "checkbox"
                ? rawValue
                  ? "true"
                  : "false"
                : String(rawValue ?? ""),
            enabled: true,
          });
        });
        return values;
      }

      async function handleSave() {
        if (!dirty) {
          setStatus("No changes to save.");
          return;
        }

        if (!validateForm()) {
          setStatus("Please fix validation errors before saving.", "error");
          return;
        }

        const payload = {
          accountNumber: elements.account.value.trim(),
          variation: elements.variation.value.trim(),
          displayName: elements.displayName.value.trim(),
          values: buildSaveValues(),
        };

        try {
          setStatus("Saving profile...");
          const response = await fetch("/api/profiles/save", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await response.json();

          if (!response.ok) {
            setStatus(data.error || "Failed to save profile.", "error");
            return;
          }

          snapshot = readSnapshot();
          updateDirtyState();
          setStatus(
            `Saved profile ${data.profile.accountNumber}/${data.profile.variation}.`,
            "success",
          );
        } catch (error) {
          setStatus(`Failed to save profile: ${String(error)}`, "error");
        }
      }
      function parseProfileValue(field, rawValue) {
        if (field.control === "checkbox") {
          const normalized = String(rawValue ?? "").toLowerCase();
          return (
            normalized === "true" ||
            normalized === "1" ||
            normalized === "yes" ||
            normalized === "on"
          );
        }
        return String(rawValue ?? "");
      }

      function applyProfileToState(profile) {
        initializeStateFromSchema();

        const sourceSettingMap = new Map();
        fieldOrder.forEach((fieldId) => {
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          if (meta.field.sourceSettingId) {
            sourceSettingMap.set(meta.field.sourceSettingId, fieldId);
          }
        });

        const values = Array.isArray(profile?.values) ? profile.values : [];
        values.forEach((item) => {
          const incoming = String(item.settingId ?? "");
          const fieldId = fieldIndex.has(incoming)
            ? incoming
            : sourceSettingMap.get(incoming);
          if (!fieldId) return;
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          formState[fieldId] = parseProfileValue(meta.field, item.value);
        });

        elements.displayName.value = profile?.displayName
          ? String(profile.displayName)
          : "";
      }

      async function handleLoad() {
        validationErrors = {};
        renderInlineErrors();

        const accountNumber = elements.account.value.trim();
        const variation = elements.variation.value.trim();
        if (!accountNumber || !variation) {
          if (!accountNumber)
            validationErrors.accountNumber = "Account is required.";
          if (!variation) validationErrors.variation = "Variation is required.";
          renderInlineErrors();
          setStatus("Account and Variation are required to load.", "error");
          return;
        }

        try {
          setStatus("Loading profile...");
          const response = await fetch("/api/profiles/get", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ accountNumber, variation }),
          });

          if (response.status === 404) {
            setStatus("Profile not found. Fill values and save to create it.");
            initializeStateFromSchema();
            renderSections();
            snapshot = readSnapshot();
            updateDirtyState();
            return;
          }

          const data = await response.json();
          if (!response.ok) {
            setStatus(data.error || "Failed to load profile.", "error");
            return;
          }

          applyProfileToState(data.profile || {});
          renderSections();
          validationErrors = {};
          renderInlineErrors();
          snapshot = readSnapshot();
          updateDirtyState();
          setStatus(`Loaded profile ${accountNumber}/${variation}.`, "success");
        } catch (error) {
          setStatus(`Failed to load profile: ${String(error)}`, "error");
        }
      }

      function handleNewClear() {
        elements.account.value = "";
        elements.variation.value = "";
        elements.displayName.value = "";
        validationErrors = {};
        initializeStateFromSchema();
        renderSections();
        snapshot = readSnapshot();
        updateDirtyState();
        setStatus("Form reset.");
      }

      function handleDiscard() {
        if (!snapshot) return;

        elements.account.value = snapshot.accountNumber;
        elements.variation.value = snapshot.variation;
        elements.displayName.value = snapshot.displayName;

        fieldOrder.forEach((fieldId) => {
          const meta = fieldIndex.get(fieldId);
          if (!meta) return;
          formState[fieldId] = normalizeValueForField(
            meta.field,
            snapshot.values[fieldId],
          );
        });

        validationErrors = {};
        renderSections();
        updateDirtyState();
        setStatus("Changes discarded.");
      }

      function handleStickyBar() {
        const hasVisibleErrors = Object.keys(validationErrors).some((key) => {
          if (
            key === "accountNumber" ||
            key === "variation" ||
            key === "displayName"
          )
            return true;
          return isFieldActive(key);
        });

        elements.stickySave.classList.toggle("show", dirty);
        elements.stickySaveBtn.disabled = !dirty || hasVisibleErrors;
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      async function loadSchema() {
        const response = await fetch("/api/form/schema");
        if (!response.ok) {
          throw new Error(`Schema request failed (${response.status})`);
        }
        const payload = await response.json();
        schema = payload;
        buildIndexes();
        initializeStateFromSchema();
      }

      function bindMetaListeners() {
        [elements.account, elements.variation, elements.displayName].forEach(
          (input) => {
            input.addEventListener("input", () => {
              if (
                input === elements.account &&
                validationErrors.accountNumber
              ) {
                delete validationErrors.accountNumber;
              }
              if (input === elements.variation && validationErrors.variation) {
                delete validationErrors.variation;
              }
              if (
                input === elements.displayName &&
                validationErrors.displayName
              ) {
                delete validationErrors.displayName;
              }
              renderInlineErrors();
              updateDirtyState();
            });
          },
        );
      }

      async function init() {
        try {
          loadCollapseStateFromSession();
          await loadSchema();
          renderSections();
          bindMetaListeners();

          elements.loadBtn.addEventListener("click", handleLoad);
          elements.clearBtn.addEventListener("click", handleNewClear);
          elements.saveBtn.addEventListener("click", handleSave);
          elements.stickySaveBtn.addEventListener("click", handleSave);
          elements.stickyDiscardBtn.addEventListener("click", handleDiscard);

          snapshot = readSnapshot();
          updateDirtyState();
          setStatus("Schema loaded.", "success");
        } catch (error) {
          setStatus(`Failed to initialize form: ${String(error)}`, "error");
        }
      }

      init();
    </script>
  </body>
</html>
